CodeEmit ::= (
  ...args:
    | [TemplateStringsArray, ...values: unknown[]]
    | [codeStr: string, cb?: =>]
) => Literal|Template

class N
  children: N[] = []
  depthInc = 0

  selfContent(): string?
    undefined

  afterContent(_: AfterContentArgs): string?
    undefined

  visit({
    before::(n: N, depth: number)=> = =>
    after::(n: N, depth: number)=> = =>
    depth::number = 0
  })
    before @, depth
    for c of @children
      c.visit { before, after, depth: depth + @depthInc }
    after @, depth

  undefer()

  asFunction(context: Context)
    Object.setPrototypeOf context@runBlock(@), @

interface AfterContentArgs
  closers: Record<string, string?>


class Context
  stack: N[] = []

  @(root: N)
    @stack.push root

  addChild<T < N>(n: T)
    @stack.at(-1)!.children.push n
    n

  runBlock<T < N>(parent: T, codeBlock = =>): T
    @stack.push parent
    codeBlock()
    @stack.pop()
    parent

interface Callable
  (cb: =>): N


// This merges with Literal's interface so that TS knows instances of Literal are callable
interface Literal < Callable

class Literal < N
  depthInc = 1

  @(@str: string, context: Context)
    super()
    return @asFunction(context)

  selfContent()
    @str

  afterContent({ closers }: AfterContentArgs)
    if @children#
      closersFor(@str, closers)


// This merges with Template's interface so that TS knows instances of Template are callable
interface Template < Callable

class Template < N
  depthInc = 1

  @(@strs: TemplateStringsArray, @values: unknown[], context: Context)
    super()
    return @asFunction(context)

  selfContent()
    [firstStr, ...restStrs] := @strs
    values := [...@values]
    src .= firstStr
    for str of restStrs
      src += values.shift()
      src += str
    src

  afterContent({ closers }: AfterContentArgs)
    if @children#
      closersFor(@strs.at(-1)!, closers)


function closersFor(str: string, closers: Record<string, string?>)
  let output: string?

  input .= str

  while input#
    for [left, right] of Object.entries(closers)
      if input.endsWith(left)
        if right?
          output ?= ''
          output += right

        input = input.slice(0, -left#)

        continue while

    break

  output


class Deferred < N
  @(@context: Context, @block: =>)
    super()

  undefer()
    @context.runBlock(@, @block)


interface GenOptions
  indent: string
  writeLine: (str: string) => void
  closers: Record<string, string?>


interface GenCodeBlockHelpers
  defer: (cb: =>) => void

GenCodeBlock ::= (code: CodeEmit, helpers: GenCodeBlockHelpers) =>


defaultClosers := {
  '{': '}'
  '[': ']'
  '(': ')'
  '<': '>'
  ' ': undefined
}


function cecil(options: Partial<GenOptions> = {})
  opts: GenOptions := {
    indent: '  '
    writeLine: console.log
    closers: defaultClosers
    ...options
  }

  {
    string(cb: GenCodeBlock)
      output .= ''
      writeLine := (line: string) => output += line + '\n'
      generate({ ...opts, writeLine }, cb)
      output

    generate(writeLine: GenOptions['writeLine'], cb: GenCodeBlock)
      generate({ ...opts, writeLine  }, cb)

    log(cb: GenCodeBlock)
      generate({ ...opts, writeLine: console.log}, cb)
  }


function generate({ writeLine, indent, closers }: GenOptions,  genCb: GenCodeBlock)
  root := new N()
  context := new Context(root)

  code: CodeEmit := (strs, ...rest) =>
    context.addChild
      if typeof strs is 'string'
        cb := rest[0] as =>?
        new Literal(strs, context) |> context.runBlock(., cb)
      else
        new Template(strs, rest, context)

  function defer(cb: =>)
    context.addChild new Deferred(context, cb)

  genCb code, { defer }

  root.visit after: (n) => n.undefer()

  function padding(depth: number)
    [1..depth].map(=> indent).join('')

  root.visit
    before: (n, depth) =>
      content := n.selfContent()
      if content?
        writeLine padding(depth) + content
    after: (n, depth) =>
      content := n.afterContent({ closers })
      if content?
        writeLine padding(depth) + content


cecil().log (c, { defer }) =>
  model := 'User'
  field_name := 'name'

  imports: string[] := []

  defer =>
    c`import ${imports.join(', ')}` =>
      c`from './models'`
      c``

  imports.push 'Import1'

  c`class ${model} extends Model ({` =>
    c("somethking {") =>
      c`name: string`
    c `somethking {`
