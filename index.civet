CodeEmit ::= (
  ...args:
    | [TemplateStringsArray, ...values: unknown[]]
    | [codeStr: string, cb?: =>]
) => Literal

// This merges with N's interface so that TS knows N is callable
interface Callable
  (cb: =>): N

class N
  children: N[] = []

  selfContent(): string?
    undefined

  depthInc = 0

  visit(cb: (n: N, depth: number) => void, depth: number = 0): void
    cb @, depth
    for c of @children
      c.visit cb, depth + @depthInc

  visitChildrenFirst(cb: (n: N, depth: number) => void, depth: number = -1): void
    for c of @children
      c.visit cb, depth + @depthInc
    cb @, depth

  undefer()

Context ::= { runBlock: (current: N, codeBlock: =>) => void }

interface Literal extends Callable

class Literal < N
  str: string
  depthInc = 1

  @(@str: string, context: Context)
    super()

    fn := (codeBlock: =>) =>
      context.runBlock(@, codeBlock)
      @

    return Object.setPrototypeOf fn, @

  selfContent()
    @str

class Deferred < N
  @(@context: Context, @block: =>)
    super()

  undefer()
    @context.runBlock(@, @block)

function makeContextFn(parentContext: { current: N })
  (block: =>) =>
    block()

function generateString(
  genCb: (
    code: CodeEmit,
    helpers: {
      defer: (cb: =>) => void
    }
  ) =>
)
  root := new N
  stack := [root]

  context := {
    runBlock(parent: N, block: =>)
      stack.push parent
      block()
      stack.pop()
  }

  code: CodeEmit := (strs, ...rest) =>
    let src: string
    cb?: => .= undefined

    if typeof strs is 'string'
      src = strs
      cb = rest[0] as (=>)?
    else
      [firstStr, ...restStrs] := strs
      src = firstStr
      for str of restStrs
        src += rest.shift()
        src += str

    n := new Literal(src, context)
    stack.at(-1)!.children.push n

    // if called like c "...", => ...
    if cb then context.runBlock(n, cb)

    n

  function defer(cb: =>)
    n := new Deferred(context, cb)
    stack.at(-1)!.children.push n
    n

  genCb(code, { defer })

  root.visitChildrenFirst .undefer()

  return root.visit (n, depth) ->
    content := n.selfContent()
    if content?
      padding := [1..depth].map(=> '  ').join('')
      console.log padding + content

generateString (c, { defer }) =>
  model := 'User'
  field_name := 'name'

  imports: string[] := []

  defer =>
    c`import ${imports.join(', ')}` =>
      c`from './models'`

  imports.push 'Import1'

  c`class ${model} extends Model {` =>
    c`somethking`
