CodeEmit ::= (
  ...args:
    | [TemplateStringsArray, ...values: unknown[]]
    | [codeStr: string, cb?: =>]
) => Literal

// This merges with N's interface so that TS knows N is callable
interface Callable
  (cb: =>): N

class N
  children: N[] = []

  selfContent(): string?
    undefined

  depthInc = 0

  visit({
    before:: (n: N, depth: number) => void = =>
    after:: (n: N, depth: number) => void = =>
    depth:: number = 0
  }): void
    before @, depth
    for c of @children
      c.visit { before, after, depth: depth + @depthInc }
    after @, depth

  undefer()

Context ::= { runBlock: (current: N, codeBlock: =>) => void }

interface Literal extends Callable

class Literal < N
  str: string
  depthInc = 1

  @(@str: string, context: Context)
    super()

    fn := (codeBlock: =>) =>
      context.runBlock(@, codeBlock)
      @

    return Object.setPrototypeOf fn, @

  selfContent()
    @str

class Deferred < N
  @(@context: Context, @block: =>)
    super()

  undefer()
    @context.runBlock(@, @block)

function makeContextFn(parentContext: { current: N })
  (block: =>) =>
    block()

GenOptions ::= {
  indent: string
  writeLine: (str: string) => void
}
GenCodeBlock ::= (
  code: CodeEmit,
  helpers: {
    defer: (cb: =>) => void
  }
) =>

function cecil(options: Partial<GenOptions> = {})
  opts: GenOptions := {
    indent: '  '
    writeLine: console.log
    ...options
  }

  {
    string(cb: GenCodeBlock)
      output .= ''
      writeLine := (line: string) => output += line + '\n'
      generate({ ...opts, writeLine }, cb)
      output

    generate(writeLine: GenOptions['writeLine'], cb: GenCodeBlock)
      generate({ ...opts, writeLine  }, cb)

    log(cb: GenCodeBlock)
      generate({ ...opts, writeLine: console.log}, cb)
  }

function generate({ writeLine, indent}: GenOptions,  genCb: GenCodeBlock)
  root := new N
  stack := [root]

  context := {
    runBlock(parent: N, block: =>)
      stack.push parent
      block()
      stack.pop()
  }

  code: CodeEmit := (strs, ...rest) =>
    let src: string
    cb?: => .= undefined

    if typeof strs is 'string'
      src = strs
      cb = rest[0] as (=>)?
    else
      [firstStr, ...restStrs] := strs
      src = firstStr
      for str of restStrs
        src += rest.shift()
        src += str

    n := new Literal(src, context)
    stack.at(-1)!.children.push n

    // if called like c "...", => ...
    if cb then context.runBlock(n, cb)

    n

  function defer(cb: =>)
    n := new Deferred(context, cb)
    stack.at(-1)!.children.push n
    n

  genCb(code, { defer })

  root.visit after: (n) => n.undefer()

  root.visit before: (n, depth) =>
    content := n.selfContent()
    if content?
      padding := [1..depth].map(=> indent).join('')
      writeLine padding + content


cecil().log (c, { defer }) =>
  model := 'User'
  field_name := 'name'

  imports: string[] := []

  defer =>
    c`import ${imports.join(', ')}` =>
      c`from './models'`
      c``

  imports.push 'Import1'

  c`class ${model} extends Model {` =>
    c`somethking`
